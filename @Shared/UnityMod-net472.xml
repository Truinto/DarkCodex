<?xml version="1.0"?>
<doc>
    <assembly>
        <name>UnityMod</name>
    </assembly>
    <members>
        <member name="T:Shared.LocalParameterAttribute">
            <summary>
            Local selection for TranspilerTool delegate.
            </summary>
            <remarks>
            If you want to define the local dynamically inside the transpiler, then define <see cref="F:Shared.LocalParameterAttribute.Name"/> and set the name via TranspilerTool.NameLocal.
            </remarks>
        </member>
        <member name="F:Shared.LocalParameterAttribute.Name">
            <summary>Name of local.</summary>
        </member>
        <member name="F:Shared.LocalParameterAttribute.Type">
            <summary>Type of local. If missing, will assume by type of parameter.</summary>
        </member>
        <member name="F:Shared.LocalParameterAttribute.Index">
            <summary>Index of local.</summary>
        </member>
        <member name="F:Shared.LocalParameterAttribute.IndexByType">
            <summary>Index of local, filtered by exactly matching type.</summary>
        </member>
        <member name="M:Shared.LocalParameterAttribute.#ctor(System.String,System.Type,System.Int32,System.Int32)">
            <summary>
            Parameter will be called with a local. By indices is only valid for original locals. Use name for self declared locals. <br/>
            If <b>name</b> is set, will look for self declared local or create one. <br/>
            If <b>index</b> is 0 or greater, the absolute index will be chosen. If the type is incompatable an exception is thrown. <br/>
            If <b>indexByType</b> is 0 or greater, the index in a collection of exact matching type will be chosen. <br/>
            If both indices are below zero, the current CodeInstruction will determine the local. 
            </summary>
        </member>
        <member name="T:Shared.OriginalParameterAttribute">
            <summary>
            Original parameter selection. If you need to define a different name.
            </summary>
        </member>
        <member name="F:Shared.OriginalParameterAttribute.Name">
            <summary>Original method name this parameter should be loaded with.</summary>
        </member>
        <member name="M:Shared.OriginalParameterAttribute.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.CacheData`1">
            <summary>
            Cache for slow operations. Will return known solution to specified arguments. Otherwise calls getter and remembers solution in cache.
            </summary>
        </member>
        <member name="M:Shared.CacheData`1.#ctor(System.Func{System.Object[],`0},System.Int32)">
            <summary>
            Cache for slow operations. Will return known solution to specified arguments. Otherwise calls getter and remembers solution in cache.
            </summary>
            <param name="getter">Function to resolve unknown solution.</param>
            <param name="size">Cache size.</param>
        </member>
        <member name="M:Shared.CacheData`1.Get(System.Object[])">
            <summary>
            Get solution for specific argument collection. Calls getter, if solution not in cache.
            </summary>
        </member>
        <member name="T:Shared.ExceptionMissingReturn">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingReturn.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingReturn.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionInvalidReturn">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidReturn.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidReturn.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionMissingInstance">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingInstance.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingInstance.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionMissingParameter">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingParameter.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingParameter.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionInvalidParameter">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidParameter.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidParameter.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionMissingResult">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingResult.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingResult.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionInvalidResult">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidResult.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidResult.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionInvalidInstance">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidInstance.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidInstance.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionInvalidParameterOrder">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidParameterOrder.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionInvalidParameterOrder.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.ExceptionMissingRef">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingRef.#ctor">
            <summary></summary>
        </member>
        <member name="M:Shared.ExceptionMissingRef.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:Shared.LocalizedStringCached">
            <summary>
            Flexible LocalizedString whose logic depends on <see cref="F:Shared.LocalizedStringCached.Resolver"/>.
            </summary>
        </member>
        <member name="F:Shared.LocalizedStringCached.Default">
            <summary>Original string value.</summary>
        </member>
        <member name="F:Shared.LocalizedStringCached.Resolver">
            <summary>Function to resolve key to localized string.</summary>
        </member>
        <member name="M:Shared.LocalizedStringCached.#ctor(System.String)">
            <inheritdoc cref="T:Shared.LocalizedStringCached"/>
        </member>
        <member name="M:Shared.LocalizedStringCached.Clear">
            <summary>
            Clear cache. Next access will pull from Resolver again.
            </summary>
        </member>
        <member name="M:Shared.LocalizedStringCached.ToString">
            <summary>
            Pulls string from Resolver and caches result.
            </summary>
        </member>
        <member name="M:Shared.LocalizedStringCached.op_Implicit(Shared.LocalizedStringCached)~System.String">
            <inheritdoc cref="M:Shared.LocalizedStringCached.ToString"/>
        </member>
        <member name="M:Shared.LocalizedStringCached.op_Implicit(System.String)~Shared.LocalizedStringCached">
            <inheritdoc cref="T:Shared.LocalizedStringCached"/>
        </member>
        <member name="T:Shared.BaseSettings`1">
            <summary>
            Inherit this class in your settings class. Implements basic load/save functions.
            </summary>
            <typeparam name="T">Class that contains settings.</typeparam>
        </member>
        <member name="P:Shared.BaseSettings`1.Version">
            <summary>File version. Overwrite this in the constructor.</summary>
        </member>
        <member name="P:Shared.BaseSettings`1.NewFeatureDefaultOn">
            <summary>Whenever new features should be considered on by default.</summary>
        </member>
        <member name="P:Shared.BaseSettings`1.Blacklist">
            <summary>Collection of features explicitly turned off.</summary>
        </member>
        <member name="P:Shared.BaseSettings`1.Whitelist">
            <summary>Collection of features explicitly turned on.</summary>
        </member>
        <member name="F:Shared.BaseSettings`1.FilePath">
            <summary>File path to load from / save to.</summary>
        </member>
        <member name="F:Shared.BaseSettings`1.JSettings">
            <summary>Serialization settings.</summary>
        </member>
        <member name="M:Shared.BaseSettings`1.OnUpdate">
            <summary>
            Called, if file version is different from current version. Return true, if file should be saved.
            </summary>
        </member>
        <member name="M:Shared.BaseSettings`1.TrySave">
            <summary>
            Try save file.
            </summary>
        </member>
        <member name="M:Shared.BaseSettings`1.TryLoad(System.String,System.String)">
            <summary>
            Try load file. Creates new file, if loading failed for any reason.
            </summary>
            <param name="path">Path settings should be saved.</param>
            <param name="file">Name of settings file. Should include file extension.</param>
        </member>
        <member name="T:Shared.ISettings">
            <summary>
            Abstract settings interface.
            </summary>
        </member>
        <member name="P:Shared.ISettings.Version">
            <summary>File version.</summary>
        </member>
        <member name="P:Shared.ISettings.NewFeatureDefaultOn">
            <summary>Whenever new features should be considered on by default.</summary>
        </member>
        <member name="P:Shared.ISettings.Blacklist">
            <summary>Collection of features explicitly turned off.</summary>
        </member>
        <member name="P:Shared.ISettings.Whitelist">
            <summary>Collection of features explicitly turned on.</summary>
        </member>
        <member name="T:Shared.TranspilerTool">
            <summary>
            Tool to automate transpiler modifications.
            </summary>
        </member>
        <member name="F:Shared.TranspilerTool.BindingAll">
            <summary></summary>
        </member>
        <member name="F:Shared.TranspilerTool.BindingInstance">
            <summary></summary>
        </member>
        <member name="F:Shared.TranspilerTool.BindingStatic">
            <summary></summary>
        </member>
        <member name="F:Shared.TranspilerTool.Index">
            <summary>Index of the currently selected line. 'Index' usually refers to this variable.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.Code">
            <summary>Collection of all CodeInstructions.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.Generator">
            <summary>ILGenerator. Required for creating new labels or locals.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.Original">
            <summary>MethodInfo of Original. 'Original' usually refers to the method being patched by the transpiler.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.Locals">
            <summary>Collection of locals used by the original method.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.LocalsExtended">
            <summary>Full collection of locals, original or created by this tool.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.LabelsExtended">
            <summary>Full collection of labels, original or created by this tool.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.Current">
            <summary>Currently selected line of code.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.Next">
            <summary>Line of code after selection. Does not move index. Returns null, if end of code.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.Previous">
            <summary>Line of code before selection. Does not move index. Returns null, if index is 0.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.IsStatic">
            <summary>True if original method is static. False if it's an instance object.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.IsFirst">
            <summary>True if index is 0.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.IsLast">
            <summary>True if index is beyond the collection of lines.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.Count">
            <summary>Total count of lines.</summary>
        </member>
        <member name="P:Shared.TranspilerTool.IsReadOnly">
            <summary></summary>
        </member>
        <member name="P:Shared.TranspilerTool.Item(System.Int32)">
            <summary>Code of a specific index. Does not move selected index.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.#ctor(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction},System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>
            Requires all optional objects from HarmonyTranspiler. Throws if any is null or original is not of type MethodInfo.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.First">
            <summary>
            Moves index to first line.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Last">
            <summary>
            Moves index to last line.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Offset(System.Int32)">
            <summary>
            Moves index by <paramref name="offset"/>. Negative values are allowed. Does not go past boundaries.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Seek(System.Func{Shared.TranspilerTool,System.Boolean})">
            <summary>
            Moves index forward until predicate matches. Throws if no match found.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Rewind(System.Func{Shared.TranspilerTool,System.Boolean})">
            <summary>
            Moves index backward until predicate matches. Throws if no match found.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Seek(System.Type,System.String,System.Type[],System.Type[])">
            <summary>
            Moves index forward until calling a matching method or accessing a matching field. <br/>
            Also resolves property getter, but their setter is ignored.
            </summary>
            <seealso cref="M:Shared.TranspilerTool.GetMemberInfo(System.Type,System.String,System.Type[],System.Type[])"/>
        </member>
        <member name="M:Shared.TranspilerTool.Rewind(System.Type,System.String,System.Type[],System.Type[])">
            <summary>
            Moves index backward until calling a matching method or accessing a matching field. <br/>
            Also resolves property getter, but their setting is ignored.
            </summary>
            <seealso cref="M:Shared.TranspilerTool.GetMemberInfo(System.Type,System.String,System.Type[],System.Type[])"/>
        </member>
        <member name="M:Shared.TranspilerTool.Seek(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Moves index forward until a specified OpCode is used. Can optionally compare the operand as well.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Rewind(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Moves index backward until a specified OpCode is used. Can optionally compare the operand as well.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Seek(System.Boolean,System.Func{Shared.TranspilerTool,System.Boolean}[])">
            <summary>
            Moves index forward until predicates match in order. <br/>
            If <paramref name="onStart"/> is true, will place index to the start of the match. Otherwise at the end.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.Is(System.Reflection.Emit.OpCode)">
            <summary>Checks if current line matches OpCode.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.Is(System.Reflection.Emit.OpCode,System.Object)">
            <summary>Checks if current line matches OpCode and operand.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.Calls(System.Type,System.String,System.Type[],System.Type[])">
            <summary>
            Checks if current line calls or gets given member.
            </summary>
            <seealso cref="M:Shared.TranspilerTool.GetMemberInfo(System.Type,System.String,System.Type[],System.Type[])"/>
        </member>
        <member name="M:Shared.TranspilerTool.Calls(System.Reflection.MemberInfo)">
            <summary>
            Checks if current line calls or gets given member.
            </summary>
            <seealso cref="M:Shared.TranspilerTool.GetMemberInfo(System.Type,System.String,System.Type[],System.Type[])"/>
        </member>
        <member name="M:Shared.TranspilerTool.IsStloc(System.Int32)">
            <summary>Checks if current line stores local and has matching index.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsStloc(System.String)">
            <summary>Checks if current line stores local and has matching name.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsStloc(System.Type)">
            <summary>Checks if current line stores local and has exactly matching type.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsLdloc(System.Int32)">
            <summary>Checks if current line loads local and has matching index.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsLdloc(System.String)">
            <summary>Checks if current line loads local and has matching name.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsLdloc(System.Type)">
            <summary>Checks if current line loads local and has exactly matching type.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsLoadConstant(System.Int64)">
            <summary>Checks if current line loads a constant.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsLoadConstant(System.Enum)">
            <summary>Checks if current line loads a constant.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.IsLoadConstant(System.Double)">
            <summary>Checks if current line loads a constant.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.InsertCall(System.Delegate,System.Boolean)">
            <summary>
            Injects call. Increments index. Same as <see cref="M:Shared.TranspilerTool.InsertAfter(System.Delegate)"/> or <see cref="M:Shared.TranspilerTool.InsertBefore(System.Delegate)"/> <br/>
            Delegate may return void. Otherwise the <b>first parameter is taken from the stack and replaced with the return value</b>.<br/>
            <b>[T] Function([T __stack], [object __instance], [object arg0], [object arg1...])</b>
            </summary>
            <param name="func"><b>[T] Function([T __stack], [object __instance], [object arg0], [object arg1...])</b></param>
            <param name="before">If true will inject delegate before current line (still pointing to the same code). Otherwise after (pointing to the new code).</param>
            <remarks>
            The delegate may define any of the original parameters, locals, and __instance (if non-static).<br/>
            These optional parameters are matched by name, with <see cref="T:Shared.LocalParameterAttribute"/>, or with <see cref="T:Shared.OriginalParameterAttribute"/>.<br/>
            If <see cref="T:Shared.LocalParameterAttribute"/> doesn't match any existing locals, then a new one is generated. Non matching parameters will throw.<br/>
            If the optional parameter's source is ref (or out), then the delegate must also use ref. Otherwise ref is optional.
            </remarks>
        </member>
        <member name="M:Shared.TranspilerTool.InsertPushLocal(System.Boolean,System.Reflection.ParameterInfo)">
            <summary>
            Tries to push local onto stack. Returns true if successfull.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.InsertPushOriginal(System.Boolean,System.Reflection.ParameterInfo)">
            <summary>
            Tries to push original parameter onto stack. Returns true if successfull.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.InsertBefore(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Injects IL code. Increments index (still pointing to the same code).
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.InsertAfter(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Injects IL code. Increments index (pointing to the new code).
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.InsertBefore(System.Delegate)">
            <summary>
            Injects call. Increments index (still pointing to the same code). <br/>
            Delegate may return void. Otherwise the <b>first parameter is taken from the stack and replaced with the return value</b>.<br/>
            <b>[T] Function([T __stack], [object __instance], [object arg0], [object arg1...])</b>
            </summary>
            <param name="func"><b>[T] Function([T __stack], [object __instance], [object arg0], [object arg1...])</b></param>
            <remarks>
            The delegate may define any of the original parameters, locals, and __instance (if non-static).<br/>
            These optional parameters are matched by name, with <see cref="T:Shared.LocalParameterAttribute"/>, or with <see cref="T:Shared.OriginalParameterAttribute"/>.<br/>
            If <see cref="T:Shared.LocalParameterAttribute"/> doesn't match any existing locals, then a new one is generated. Non matching parameters will throw.<br/>
            If the optional parameter's source is ref (or out), then the delegate must also use ref. Otherwise ref is optional.
            </remarks>
        </member>
        <member name="M:Shared.TranspilerTool.InsertAfter(System.Delegate)">
            <summary>
            Injects call. Increments index (pointing to the new code). <br/>
            Delegate may return void. Otherwise the <b>first parameter is taken from the stack and replaced with the return value</b>.<br/>
            <b>[T] Function([T __stack], [object __instance], [object arg0], [object arg1...])</b>
            </summary>
            <param name="func"><b>[T] Function([T __stack], [object __instance], [object arg0], [object arg1...])</b></param>
            <remarks>
            The delegate may define any of the original parameters, locals, and __instance (if non-static).<br/>
            These optional parameters are matched by name, with <see cref="T:Shared.LocalParameterAttribute"/>, or with <see cref="T:Shared.OriginalParameterAttribute"/>.<br/>
            If <see cref="T:Shared.LocalParameterAttribute"/> doesn't match any existing locals, then a new one is generated. Non matching parameters will throw.<br/>
            If the optional parameter's source is ref (or out), then the delegate must also use ref. Otherwise ref is optional.
            </remarks>
        </member>
        <member name="M:Shared.TranspilerTool.InsertAfterAll(System.Type,System.String,System.Delegate,System.Type[],System.Type[])">
            <summary>
            Same as <see cref="M:Shared.TranspilerTool.InsertAfter(System.Delegate)"/>, but iterates all lines of code.
            </summary>
            <param name="type">Declaring type of the target member.</param>
            <param name="name">Name of the target member.</param>
            <param name="func">Delegate to run after target.</param>
            <param name="parameters">Optional parameter definition, if target method is overloaded.</param>
            <param name="generics">Optional generics definition, if target method has generics.</param>
        </member>
        <member name="M:Shared.TranspilerTool.InsertAfterAll(System.Reflection.MemberInfo,System.Delegate)">
            <summary>
            Same as <see cref="M:Shared.TranspilerTool.InsertAfter(System.Delegate)"/>, but iterates all lines of code.
            </summary>
            <param name="original">Target member.</param>
            <param name="func">Delegate to run after target.</param>
        </member>
        <member name="M:Shared.TranspilerTool.InsertReturn(System.Delegate,System.Boolean)">
            <summary>
            Injects return value. Returns original method, if returning false or void. If the original has a return value, then it must be supplied with __result.<br/>
            This function will inject necessary load OpCodes.<br/>
            <b>[bool] Function(T out __result, [object __instance], [object arg0], [object arg1...])</b>
            </summary>
            <param name="func"><b>[bool] Function(T out __result, [object __instance], [object arg0], [object arg1...])</b></param>
            <param name="before">If true will inject delegate before current line (still pointing to the same code). Otherwise after (pointing to the new code).</param>
            <remarks>
            The delegate may define any of the original parameters, locals, and __instance (if non-static).<br/>
            These optional parameters are matched by name, with <see cref="T:Shared.LocalParameterAttribute"/>, or with <see cref="T:Shared.OriginalParameterAttribute"/>.<br/>
            If <see cref="T:Shared.LocalParameterAttribute"/> doesn't match any existing locals, then a new one is generated. Non matching parameters will throw.<br/>
            If the optional parameter's source is ref (or out), then the delegate must also use ref. Otherwise ref is optional.
            </remarks>
        </member>
        <member name="M:Shared.TranspilerTool.InsertJump(System.Delegate,Shared.LabelInfo,System.Boolean)">
            <summary>
            Injects jump to given label.<br/>
            This function will inject necessary load OpCodes.<br/>
            Use <see cref="M:Shared.TranspilerTool.GetLabel(HarmonyLib.CodeInstruction,System.String,System.Boolean)"/> to jump to a specific CodeInstruction.<br/>
            <b>bool Function([object __instance], [object arg0], [object arg1...])</b>
            </summary>
            <param name="func"><b>bool Function([object __instance], [object arg0], [object arg1...])</b></param>
            <param name="label">Label to jump to, if func returns true.</param>
            <param name="before">If true will inject delegate before current line (still pointing to the same code). Otherwise after (pointing to the new code).</param>
            <remarks>
            The delegate may define any of the original parameters, locals, and __instance (if non-static).<br/>
            These optional parameters are matched by name, with <see cref="T:Shared.LocalParameterAttribute"/>, or with <see cref="T:Shared.OriginalParameterAttribute"/>.<br/>
            If <see cref="T:Shared.LocalParameterAttribute"/> doesn't match any existing locals, then a new one is generated. Non matching parameters will throw.<br/>
            If the optional parameter's source is ref (or out), then the delegate must also use ref. Otherwise ref is optional.
            </remarks>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceCall(System.Delegate)">
            <summary>
            <b>Instance methods need their instance as the first parameter!</b><br/>
            Replaces the current IL line with call. The delegate must return the replacement return type and <b>must have the same parameters with identical names and order</b>.<br/>
            <b>object Function(object object_instance, object parameter0, object parameter1..., [object __instance], [object arg0], [object arg1...])</b>
            </summary>
            <param name="func"><b>object Function(object object_instance, object parameter0, object parameter1..., [object __instance], [object arg0], [object arg1...])</b></param>
            <remarks>
            The current line may contain a method call or field access.<br/>
            The delegate may define any of the original parameters, locals, and __instance (if non-static), but only after the replacement parameters.<br/>
            These optional parameters are matched by name, with <see cref="T:Shared.LocalParameterAttribute"/>, or with <see cref="T:Shared.OriginalParameterAttribute"/>.<br/>
            If <see cref="T:Shared.LocalParameterAttribute"/> doesn't match any existing locals, then a new one is generated. Non matching parameters will throw.<br/>
            If the optional parameter's source is ref (or out), then the delegate must also use ref. Otherwise ref is optional.
            </remarks>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceAllCalls(System.Type,System.String,System.Delegate,System.Type[],System.Type[])">
            <summary>
            Same as <see cref="M:Shared.TranspilerTool.ReplaceCall(System.Delegate)"/>, but iterates all lines of code.
            </summary>
            <param name="type">Declaring type of the member to be replaced.</param>
            <param name="name">Name of the member to be replaced.</param>
            <param name="func">Delegate the member should be replaced with.</param>
            <param name="parameters">Optional parameter definition, if target method is overloaded.</param>
            <param name="generics">Optional generics definition, if target method has generics.</param>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceAllCalls(System.Reflection.MemberInfo,System.Delegate)">
            <summary>
            Same as <see cref="M:Shared.TranspilerTool.ReplaceCall(System.Delegate)"/>, but iterates all lines of code.
            </summary>
            <param name="original">Target member.</param>
            <param name="func">Delegate the member should be replaced with.</param>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceConstant(System.Enum)">
            <summary>
            Change current line's load to a new value. Can be any integer type. Throws if current isn't OpCode.Ldc_i.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceConstant(System.Int64)">
            <summary>
            Change current line's load to a new value. Can be any integer type. Throws if current isn't OpCode.Ldc_i.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceConstant(System.Double)">
            <summary>
            Change current line's load to a new value. Can be any float-point type. Throws if current isn't OpCode.Ldc_r.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceAllConstant(System.Enum,System.Enum,System.Int32,System.Int32)">
            <summary>
            Change load to a new value. Can be any integer type. Throws if current isn't OpCode.Ldc_i.<br/>
            Optionally define start and end index.<br/>
            <b>0 and 1 may change boolean values too.</b>
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceAllConstant(System.Int64,System.Int64,System.Int32,System.Int32)">
            <summary>
            Change load to a new value. Can be any integer type. Throws if current isn't OpCode.Ldc_i.<br/>
            Optionally define start and end index.<br/>
            <b>0 and 1 may change boolean values too.</b>
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceAllConstant(System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Change load to a new value. Can be any float-point type. Throws if current isn't OpCode.Ldc_r.<br/>
            Optionally define start and end index.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ReplaceNOP">
            <summary>
            Change current line to NOP.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NextJumpAlways">
            <summary>
            Moves index forward until a branched jump occures. Then injects jump to the same label. <br/>
            Throws if a different type of jump is found first.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NextJumpNever">
            <summary>
            Moves index forward until a branched jump occures. Then replaces its label with a label to the next line.<br/>
            Throws if a different type of jump is found first.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetLabel(HarmonyLib.CodeInstruction,System.String,System.Boolean)">
            <summary>
            Get a label to a specific CodeInstruction. Name must be attached to this CodeInstruction or be null.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetLabel(System.String,System.Boolean)">
            <summary>
            Get label with a specific name or create a new label, if name is null or non-existent.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetLabel(System.Int32)">
            <summary>
            Get label by label index (not line index).
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NameLabel(System.Int32,System.String)">
            <summary>
            Set name of label by index.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NameLabel(System.Reflection.Emit.Label,System.String)">
            <summary>
            Set name of label.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetLocal(System.String,System.Type,System.Boolean)">
            <summary>
            Get local with a specific name or create a new local, if name is null or non-existent and type is given.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetLocal(System.Int32,System.Type)">
            <summary>
            Get local by index.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NameLocal(System.String)">
            <summary>
            Set name of local at the current index.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NameLocal(System.Int32,System.String)">
            <summary>
            Set name of local by index.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NameLocal(System.Reflection.LocalVariableInfo,System.String)">
            <summary>
            Set name of local.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.NameLocal(Shared.LocalInfo,System.String)">
            <summary>
            Set name of local.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetLocal">
            <summary>
            Get local of current line. May return empty LocalInfo.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetLocalIndex">
            <summary>
            Get index of local of current line. May return -1.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.IndexOf(HarmonyLib.CodeInstruction)">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.Insert(System.Int32,HarmonyLib.CodeInstruction)">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.RemoveAt(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.Add(HarmonyLib.CodeInstruction)">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.Clear">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.Contains(HarmonyLib.CodeInstruction)">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.CopyTo(HarmonyLib.CodeInstruction[],System.Int32)">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.Remove(HarmonyLib.CodeInstruction)">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:Shared.TranspilerTool.System#Collections#IEnumerable#GetEnumerator">
            <summary></summary>
        </member>
        <member name="F:Shared.TranspilerTool.OpCode_Ldc_i">
            <summary>Collection of Ldc_i opcodes.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.OpCode_Ldc_r">
            <summary>Collection of Ldc_r opcodes.</summary>
        </member>
        <member name="F:Shared.TranspilerTool.OpCode_Member">
            <summary>Collection of member opcodes.</summary>
        </member>
        <member name="M:Shared.TranspilerTool.op_Increment(Shared.TranspilerTool)">
            <summary>
            Increment index by 1.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.op_Decrement(Shared.TranspilerTool)">
            <summary>
            Decrement index by 1.
            </summary>
        </member>
        <member name="F:Shared.TranspilerTool._memberCache">
            <summary>
            Cache of MemberInfo.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetMemberInfo(System.Type,System.String,System.Type[],System.Type[])">
            <summary>
            Get MemberInfo for a specific method, field, or get-property.
            </summary>
            <param name="type">Declaring type.</param>
            <param name="name">Method or field name.</param>
            <param name="parameters">Only for methods.</param>
            <param name="generics">Only for methods.</param>
        </member>
        <member name="M:Shared.TranspilerTool.GetStackChange(System.Reflection.Emit.StackBehaviour)">
            <summary>
            Returns value of stack change. Zero has no change. Negative values pop from stack. Positive values push to stack.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ThrowParameterIncompatible(System.Reflection.ParameterInfo,System.Type)">
            <summary>
            Throws if type cannot be assigned to parameter. Handles by-ref resolution.<br/>
            Returns true, if operation must use dereference.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.ThrowParameterIncompatible(System.Type,System.Type)">
            <summary>
            Throws if type cannot be assigned to parameter. Handles by-ref resolution.<br/>
            Returns true, if operation must use dereference.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.HasMethodCall(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Untested. Checks if a particular method has calls to another method.<br/>
            Does not resolve wrapped method calls (e.g. lambda expressions).
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetCallers(System.Reflection.MethodInfo,System.String[],System.String[])">
            <summary>
            Untested. Returns all methods in all assemblies calling a particular method.
            </summary>
        </member>
        <member name="M:Shared.TranspilerTool.GetCallersR(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Untested. Returns <i><paramref name="parentMethod"/></i> and embedded methods which call <i><paramref name="lookingforMethod"/></i>.
            Does resolve some wrapped method calls (e.g. lambda expressions).
            </summary>
        </member>
        <member name="T:Shared.LabelInfo">
            <summary>
            Struct to hold Label and string.<br/>
            Use <see cref="M:Shared.TranspilerTool.GetLabel(System.String,System.Boolean)"/> to get or create new labels.
            </summary>
        </member>
        <member name="F:Shared.LabelInfo.Label">
            <summary></summary>
        </member>
        <member name="F:Shared.LabelInfo.Name">
            <summary></summary>
        </member>
        <member name="P:Shared.LabelInfo.Index">
            <summary></summary>
        </member>
        <member name="P:Shared.LabelInfo.IsEmpty">
            <summary></summary>
        </member>
        <member name="M:Shared.LabelInfo.#ctor(System.Reflection.Emit.Label,System.String)">
            <summary></summary>
        </member>
        <member name="M:Shared.LabelInfo.#ctor(System.Int32,System.String)">
            <summary></summary>
        </member>
        <member name="M:Shared.LabelInfo.ToString">
            <summary></summary>
        </member>
        <member name="M:Shared.LabelInfo.Equals(System.Object)">
            <summary>
            Compares LabelInfo, int, Label, or string. Always returns false if IsEmpty.
            </summary>
        </member>
        <member name="M:Shared.LabelInfo.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:Shared.LabelInfo.op_Implicit(Shared.LabelInfo)~System.Reflection.Emit.Label">
            <summary></summary>
        </member>
        <member name="M:Shared.LabelInfo.op_Implicit(Shared.LabelInfo)~System.Int32">
            <summary></summary>
        </member>
        <member name="T:Shared.LocalInfo">
            <summary>
            Struct to hold LocalVariableInfo and string.
            </summary>
        </member>
        <member name="F:Shared.LocalInfo.Local">
            <summary></summary>
        </member>
        <member name="F:Shared.LocalInfo.Name">
            <summary></summary>
        </member>
        <member name="P:Shared.LocalInfo.Index">
            <summary></summary>
        </member>
        <member name="P:Shared.LocalInfo.Type">
            <summary></summary>
        </member>
        <member name="P:Shared.LocalInfo.IsEmpty">
            <summary></summary>
        </member>
        <member name="M:Shared.LocalInfo.#ctor(System.Reflection.LocalVariableInfo,System.String)">
            <summary></summary>
        </member>
        <member name="M:Shared.LocalInfo.ToString">
            <summary></summary>
        </member>
        <member name="M:Shared.LocalInfo.Equals(System.Object)">
            <summary>
            Compares LocalInfo, int, LocalVariableInfo, or string. Always returns false if IsEmpty.
            </summary>
        </member>
        <member name="M:Shared.LocalInfo.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:Shared.LocalInfo.op_Implicit(Shared.LocalInfo)~System.Reflection.LocalVariableInfo">
            <summary></summary>
        </member>
        <member name="M:Shared.LocalInfo.op_Implicit(Shared.LocalInfo)~System.Int32">
            <summary></summary>
        </member>
        <member name="T:Shared.AttributesNS.MaybeNull">
            <summary>
            Parameter attribute. Given parameter can be null.
            </summary>
        </member>
        <member name="T:Shared.AttributesNS.NeverNull">
            <summary>
            Parameter attribute. Given parameter must not be null.
            </summary>
        </member>
        <member name="T:Shared.SerializeNS.SerializationTool">
            <summary>
            Tool to handle (de-)serialization.
            </summary>
        </member>
        <member name="T:Shared.LoggerNS.Logger">
            <summary>
            Methods to print to standard output.
            </summary>
        </member>
        <member name="M:Shared.LoggerNS.Logger.PrintDebug(System.String,System.String)">
            <summary>
            Only prints in DEBUG.
            </summary>
        </member>
        <member name="M:Shared.LoggerNS.Logger.Print(System.String)">
            <summary>
            Prints to standard output.
            </summary>
        </member>
        <member name="M:Shared.LoggerNS.Logger.PrintWarning(System.String,System.String)">
            <summary>
            Prints to standard output.
            </summary>
        </member>
        <member name="M:Shared.LoggerNS.Logger.PrintError(System.String,System.String)">
            <summary>
            Prints to standard output.
            </summary>
        </member>
        <member name="M:Shared.LoggerNS.Logger.PrintException(System.Exception)">
            <summary>
            Prints to standard output.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.IsTypeCompatible(System.Type,System.Type)">
            <summary>
            Checks if right type can be assigned to left type. <br/>
            Works similiar to IsAssignableFrom, but will returns false for ValueTypes (which need boxing) and void (which overflows the stack).     
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.FindIndex``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Find index in a collection by a predicate.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Find index in a collection by object.Equals.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32)">
            <summary>
            Find index in a collection by object.Equals. Returns notFound, if no element matches.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Get element at index or default.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AddUnique``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds items to a list, which are not already in the list. Compares with Equal().
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AddUnique``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Adds items to a list, which are not already in the list. Types can be different. Compares with Equal() of <typeparamref name="T1"/>.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AddUnique2``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Adds items to a list, which are not already in the list. Types can be different. Compares with Equal() of <typeparamref name="T2"/>.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AsArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns itself, if value is an array. Otherwise creates a new array.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AsList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns itself, if value is a list. Otherwise creates a new list.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AddBefore``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns numerable with element at the first position.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AddAfter``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns numerable with element at the last position.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AddBefore``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns numerable with element at the first position.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AddAfter``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns numerable with element at the last position.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.Append``1(``0[],``0[])">
            <summary>Appends objects on array, returning a new array.</summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.Append``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Appends objects on list, returning a new list.</summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AppendAndReplace``1(``0[]@,``0[])">
            <summary>Appends objects on array and overwrites the original.</summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.AppendAndReplace``1(``0[]@,System.Collections.Generic.IEnumerable{``0})">
            <summary>Appends objects on array and overwrites the original.</summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.Ensure``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1@)">
            <summary>
            Get dictionary by key and create new value with standard constructor, if it did not exist.
            </summary>
            <returns>true if new value was created</returns>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.GetList">
            <summary>
            Gets a static list object. Do not save reference.
            Call <b>Flush&lt;T&gt;()</b> to receive output.
            </summary>
        </member>
        <member name="M:Shared.CollectionNS.CollectionTool.Flush``1">
            <summary>
            Use when finished with <b>GetList()</b>
            </summary>
        </member>
    </members>
</doc>
